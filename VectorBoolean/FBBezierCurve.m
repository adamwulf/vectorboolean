//
//  FBBezierCurve.m
//  VectorBoolean
//
//  Created by Andrew Finnell on 6/6/11.
//  Copyright 2011 Fortunate Bear, LLC. All rights reserved.
//

#import "FBBezierCurve.h"
#import "UIBezierPath+Utilities.h"
#import "Geometry.h"
#import "FBBezierIntersection.h"
#import "FBBezierIntersectRange.h"
#import "DrawKit-iOS.h"

//////////////////////////////////////////////////////////////////////////////////
// Normalized lines
//
typedef struct FBNormalizedLine {
    CGFloat a; // * x +
    CGFloat b; // * y +
    CGFloat c; // constant
} FBNormalizedLine;

// Create a normalized line such that computing the distance from it is quick.
//  See:    http://softsurfer.com/Archive/algorithm_0102/algorithm_0102.htm#Distance%20to%20an%20Infinite%20Line
//          http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/geometry/basic.html
//
static FBNormalizedLine FBNormalizedLineMake(CGPoint point1, CGPoint point2)
{
    FBNormalizedLine line = { point1.y - point2.y, point2.x - point1.x, point1.x * point2.y - point2.x * point1.y };
    CGFloat distance = sqrt(line.b * line.b + line.a * line.a);
	
	// GPC: prevent divide-by-zero from putting NaNs into the values which cause trouble further on. I'm not sure
	// what cases trigger this, but sometimes point1 == point2 so distance is 0.
	if( distance != 0.0 ) {
		line.a /= distance;
		line.b /= distance;
		line.c /= distance;
	} else
		line.a = line.b = line.c = 0;

    return line;
}

static CGFloat FBNormalizedLineDistanceFromPoint(FBNormalizedLine line, CGPoint point)
{
    return line.a * point.x + line.b * point.y + line.c;
}


//////////////////////////////////////////////////////////////////////////////////
// Helper functions
//

// The three points are a counter-clockwise turn if the return value is greater than 0,
//  clockwise if less than 0, or colinear if 0.
static CGFloat CounterClockwiseTurn(CGPoint point1, CGPoint point2, CGPoint point3)
{
    // We're calculating the signed area of the triangle formed by the three points. Well,
    //  almost the area of the triangle -- we'd need to divide by 2. But since we only
    //  care about the direction (i.e. the sign) dividing by 2 is an unnecessary step.
    // See http://mathworld.wolfram.com/TriangleArea.html for the signed area of a triangle.
    return (point2.x - point1.x) * (point3.y - point1.y) - (point2.y - point1.y) * (point3.x - point1.x);
}

// Calculate if and where the given line intersects the horizontal line at y.
static BOOL LineIntersectsHorizontalLine(CGPoint startPoint, CGPoint endPoint, CGFloat y, CGPoint *intersectPoint)
{
    // Do a quick test to see if y even falls on the startPoint,endPoint line
    CGFloat minY = MIN(startPoint.y, endPoint.y);
    CGFloat maxY = MAX(startPoint.y, endPoint.y);
    if ( (y < minY && !FBAreValuesClose(y, minY)) || (y > maxY && !FBAreValuesClose(y, maxY)) )
        return NO;
    
    // There's an intersection here somewhere
    if ( startPoint.x == endPoint.x )
        *intersectPoint = CGPointMake(startPoint.x, y);
    else {
        CGFloat slope = (endPoint.y - startPoint.y) / (endPoint.x - startPoint.x);
        *intersectPoint = CGPointMake((y - startPoint.y) / slope + startPoint.x, y);
    }
    
    return YES;
}

static CGPoint BezierWithPoints(NSUInteger degree, CGPoint *bezierPoints, CGFloat parameter, CGPoint *leftCurve, CGPoint *rightCurve)
{
    // Calculate a point on the bezier curve passed in, specifically the point at parameter.
    //  We're using De Casteljau's algorithm, which not only calculates the point at parameter
    //  in a numerically stable way, it also computes the two resulting bezier curves that
    //  would be formed if the original were split at the parameter specified.
    //
    // See: http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/de-casteljau.html
    //  for an explaination of De Casteljau's algorithm.
    
    // bezierPoints, leftCurve, rightCurve will have a length of degree + 1. 
    // degree is the order of the bezier path, which will be cubic (3) most of the time.
    
    // With this algorithm we start out with the points in the bezier path. 
    CGPoint points[4] = {}; // we assume we'll never get more than a cubic bezier
    for (NSUInteger i = 0; i <= degree; i++)
        points[i] = bezierPoints[i];
    
    // If the caller is asking for the resulting bezier curves, start filling those in
    if ( leftCurve != nil )
        leftCurve[0] = points[0];
    if ( rightCurve != nil )
        rightCurve[degree] = points[degree];
        
    for (NSUInteger k = 1; k <= degree; k++) {
        for (NSUInteger i = 0; i <= (degree - k); i++) {
            points[i].x = (1.0 - parameter) * points[i].x + parameter * points[i + 1].x;
            points[i].y = (1.0 - parameter) * points[i].y + parameter * points[i + 1].y;            
        }
        
        if ( leftCurve != nil )
            leftCurve[k] = points[0];
        if ( rightCurve != nil )
            rightCurve[degree - k] = points[degree - k];
    }
    
    // The point in the curve at parameter ends up in points[0]
    return points[0];
}

static NSArray *FBComputeCubicFirstDerivativeRoots(CGFloat a, CGFloat b, CGFloat c, CGFloat d)
{
    // See http://processingjs.nihongoresources.com/bezierinfo/#bounds for where the formulas come from
    CGFloat denominator = -a + 3.0 * b - 3.0 * c + d;
    if ( !FBAreValuesClose(denominator, 0.0) ) {
        CGFloat numeratorLeft = -a + 2.0 * b - c;
        CGFloat numeratorRight = -sqrt(-a * (c - d) + b * b - b * (c + d) + c * c);
        CGFloat t1 = (numeratorLeft + numeratorRight) / denominator;
        CGFloat t2 = (numeratorLeft - numeratorRight) / denominator;
        return [NSArray arrayWithObjects:[NSNumber numberWithFloat:t1], [NSNumber numberWithFloat:t2], nil];
    }
    
    // If denominator == 0, fall back to 
    CGFloat t = (a - b) / (2.0 * (a - 2.0 * b + c));
    return [NSArray arrayWithObject:[NSNumber numberWithFloat:t]];
}

// Legendre-Gauss abscissae (xi values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
static CGFloat FBLegendreGaussAbscissaeValues[][24] = {{},{},
    {-0.5773502691896257310588680411456152796745,0.5773502691896257310588680411456152796745},
    {0.0000000000000000000000000000000000000000,-0.7745966692414834042779148148838430643082,0.7745966692414834042779148148838430643082},
    {-0.3399810435848562573113440521410666406155,0.3399810435848562573113440521410666406155,-0.8611363115940525725378051902225706726313,0.8611363115940525725378051902225706726313},
    {0.0000000000000000000000000000000000000000,-0.5384693101056831077144693153968546539545,0.5384693101056831077144693153968546539545,-0.9061798459386639637003213465504813939333,0.9061798459386639637003213465504813939333},
    {0.6612093864662644815410885712481103837490,-0.6612093864662644815410885712481103837490,-0.2386191860831969047129774708082550205290,0.2386191860831969047129774708082550205290,-0.9324695142031520500580654697841964662075,0.9324695142031520500580654697841964662075},
    {0.0000000000000000000000000000000000000000,0.4058451513773971841558818596240598708391,-0.4058451513773971841558818596240598708391,-0.7415311855993944600839995473506860435009,0.7415311855993944600839995473506860435009,-0.9491079123427584862682238053821492940187,0.9491079123427584862682238053821492940187},
    {-0.1834346424956498078362443493460887111723,0.1834346424956498078362443493460887111723,-0.5255324099163289908176466269651427865028,0.5255324099163289908176466269651427865028,-0.7966664774136267279658341067261062562466,0.7966664774136267279658341067261062562466,-0.9602898564975362871720676594122778624296,0.9602898564975362871720676594122778624296},
    {0.0000000000000000000000000000000000000000,-0.8360311073266357695388251158874481916428,0.8360311073266357695388251158874481916428,-0.9681602395076260858530758923734538257122,0.9681602395076260858530758923734538257122,-0.3242534234038089158147499801998492330313,0.3242534234038089158147499801998492330313,-0.6133714327005903577116896485676988959312,0.6133714327005903577116896485676988959312},
    {-0.1488743389816312157059030596428783610463,0.1488743389816312157059030596428783610463,-0.4333953941292472133994806426926515996456,0.4333953941292472133994806426926515996456,-0.6794095682990244355892173189204186201096,0.6794095682990244355892173189204186201096,-0.8650633666889845363456856830453034490347,0.8650633666889845363456856830453034490347,-0.9739065285171717434309357486199587583542,0.9739065285171717434309357486199587583542},
    {0.0000000000000000000000000000000000000000,-0.2695431559523449593918087430211016908288,0.2695431559523449593918087430211016908288,-0.5190961292068118071441062966187018901110,0.5190961292068118071441062966187018901110,-0.7301520055740493564400139803183265030384,0.7301520055740493564400139803183265030384,-0.8870625997680953167545681026240345090628,0.8870625997680953167545681026240345090628,-0.9782286581460569729884468870295677334070,0.9782286581460569729884468870295677334070},
    {-0.1252334085114689132822718420356977730989,0.1252334085114689132822718420356977730989,-0.3678314989981801841345543380157323554158,0.3678314989981801841345543380157323554158,-0.5873179542866174829285341729701030999422,0.5873179542866174829285341729701030999422,-0.7699026741943046925342741815256886184216,0.7699026741943046925342741815256886184216,-0.9041172563704749087776235683122649788857,0.9041172563704749087776235683122649788857,-0.9815606342467192435563561048184055835009,0.9815606342467192435563561048184055835009},
    {0.0000000000000000000000000000000000000000,-0.2304583159551348015003924274424207396805,0.2304583159551348015003924274424207396805,-0.4484927510364468683512484403763664886355,0.4484927510364468683512484403763664886355,-0.6423493394403402279024817289609927684069,0.6423493394403402279024817289609927684069,-0.8015780907333098781464286730624735355377,0.8015780907333098781464286730624735355377,-0.9175983992229779229177211163914762437344,0.9175983992229779229177211163914762437344,-0.9841830547185881350458203087328001856804,0.9841830547185881350458203087328001856804},
    {-0.1080549487073436676354276642086915671825,0.1080549487073436676354276642086915671825,-0.3191123689278897446186533670697826892138,0.3191123689278897446186533670697826892138,-0.5152486363581540995681962158414535224438,0.5152486363581540995681962158414535224438,-0.6872929048116854788830210054584313184023,0.6872929048116854788830210054584313184023,-0.8272013150697650196718768711434677243233,0.8272013150697650196718768711434677243233,-0.9284348836635735180422557277779560536146,0.9284348836635735180422557277779560536146,-0.9862838086968123141318187663273420184851,0.9862838086968123141318187663273420184851},
    {0.0000000000000000000000000000000000000000,-0.2011940939974345143870237961891689337790,0.2011940939974345143870237961891689337790,-0.3941513470775633853904196257644798606634,0.3941513470775633853904196257644798606634,-0.5709721726085388304738899023504927754402,0.5709721726085388304738899023504927754402,-0.7244177313601700696210627938853576779366,0.7244177313601700696210627938853576779366,-0.8482065834104272061821916395274456590414,0.8482065834104272061821916395274456590414,-0.9372733924007059513883177714888006448746,0.9372733924007059513883177714888006448746,-0.9879925180204853774057482951320707798004,0.9879925180204853774057482951320707798004},
    {-0.0950125098376374405129141109682677779347,0.0950125098376374405129141109682677779347,-0.2816035507792589154263396267197094857693,0.2816035507792589154263396267197094857693,-0.4580167776572273696800152720243204385042,0.4580167776572273696800152720243204385042,-0.6178762444026437705701937375124543905258,0.6178762444026437705701937375124543905258,-0.7554044083550029986540153004170861095190,0.7554044083550029986540153004170861095190,-0.8656312023878317551961458775622304528952,0.8656312023878317551961458775622304528952,-0.9445750230732326002680565579794347286224,0.9445750230732326002680565579794347286224,-0.9894009349916499385102497399202547967434,0.9894009349916499385102497399202547967434},
    {0.0000000000000000000000000000000000000000,-0.1784841814958478545261044700964703224599,0.1784841814958478545261044700964703224599,-0.3512317634538763000406902392569463700056,0.3512317634538763000406902392569463700056,-0.5126905370864769384553483178024180233479,0.5126905370864769384553483178024180233479,-0.6576711592166907260903485621383879333735,0.6576711592166907260903485621383879333735,-0.7815140038968013680431567991035990417004,0.7815140038968013680431567991035990417004,-0.8802391537269859123071569229068700224161,0.8802391537269859123071569229068700224161,-0.9506755217687677950166857954172883182764,0.9506755217687677950166857954172883182764,-0.9905754753144173641032921295845881104469,0.9905754753144173641032921295845881104469},
    {-0.0847750130417353059408824833553808275610,0.0847750130417353059408824833553808275610,-0.2518862256915054831374334298743633553386,0.2518862256915054831374334298743633553386,-0.4117511614628426297457508553634397685528,0.4117511614628426297457508553634397685528,-0.5597708310739475390249708652845583856106,0.5597708310739475390249708652845583856106,-0.6916870430603532238222896921797655522823,0.6916870430603532238222896921797655522823,-0.8037049589725231424353069087374024093151,0.8037049589725231424353069087374024093151,-0.8926024664975557021406871172075625509024,0.8926024664975557021406871172075625509024,-0.9558239495713977129653926567698363214731,0.9558239495713977129653926567698363214731,-0.9915651684209308980300079383596312254667,0.9915651684209308980300079383596312254667},
    {0.0000000000000000000000000000000000000000,-0.1603586456402253668240831530056311748922,0.1603586456402253668240831530056311748922,-0.3165640999636298302810644145210972055793,0.3165640999636298302810644145210972055793,-0.4645707413759609383241411251219687983394,0.4645707413759609383241411251219687983394,-0.6005453046616809897884081692609470337629,0.6005453046616809897884081692609470337629,-0.7209661773352293856476080691209062933922,0.7209661773352293856476080691209062933922,-0.8227146565371428188484514976153150200844,0.8227146565371428188484514976153150200844,-0.9031559036148179009373393455462064594030,0.9031559036148179009373393455462064594030,-0.9602081521348300174878431789693422615528,0.9602081521348300174878431789693422615528,-0.9924068438435843519940249279898125678301,0.9924068438435843519940249279898125678301},
    {-0.0765265211334973383117130651953630149364,0.0765265211334973383117130651953630149364,-0.2277858511416450681963397073559463024139,0.2277858511416450681963397073559463024139,-0.3737060887154195487624974703066982328892,0.3737060887154195487624974703066982328892,-0.5108670019508271264996324134699534624815,0.5108670019508271264996324134699534624815,-0.6360536807265150249790508496516849845648,0.6360536807265150249790508496516849845648,-0.7463319064601507957235071444301865994930,0.7463319064601507957235071444301865994930,-0.8391169718222187823286617458506952971220,0.8391169718222187823286617458506952971220,-0.9122344282513259461353527512983419001102,0.9122344282513259461353527512983419001102,-0.9639719272779138092843709273438435047865,0.9639719272779138092843709273438435047865,-0.9931285991850948846604296704754233360291,0.9931285991850948846604296704754233360291},
    {0.0000000000000000000000000000000000000000,-0.1455618541608950933241573011400760151446,0.1455618541608950933241573011400760151446,-0.2880213168024011172185794293909566476941,0.2880213168024011172185794293909566476941,-0.4243421202074387776903563462838064879179,0.4243421202074387776903563462838064879179,-0.5516188358872198271853903861483559012413,0.5516188358872198271853903861483559012413,-0.6671388041974123384036943207320291548967,0.6671388041974123384036943207320291548967,-0.7684399634756778896260698275000322610140,0.7684399634756778896260698275000322610140,-0.8533633645833172964856316866644192487001,0.8533633645833172964856316866644192487001,-0.9200993341504007938524978271743748337030,0.9200993341504007938524978271743748337030,-0.9672268385663063128276917268522083759308,0.9672268385663063128276917268522083759308,-0.9937521706203894522602126926358323544264,0.9937521706203894522602126926358323544264},
    {-0.0697392733197222253194169638845778536052,0.0697392733197222253194169638845778536052,-0.2078604266882212725509049278116435743868,0.2078604266882212725509049278116435743868,-0.3419358208920842412403828802780481055379,0.3419358208920842412403828802780481055379,-0.4693558379867570073962212973128771409392,0.4693558379867570073962212973128771409392,-0.5876404035069116016387624767958186566830,0.5876404035069116016387624767958186566830,-0.6944872631866827461522007070016115903854,0.6944872631866827461522007070016115903854,-0.7878168059792081123759999172762036323547,0.7878168059792081123759999172762036323547,-0.8658125777203001804949167308222968131304,0.8658125777203001804949167308222968131304,-0.9269567721871739829353487039043102413416,0.9269567721871739829353487039043102413416,-0.9700604978354286922481719557254109531641,0.9700604978354286922481719557254109531641,-0.9942945854823992402060639506089501082897,0.9942945854823992402060639506089501082897},
    {0.0000000000000000000000000000000000000000,-0.1332568242984661088801345840693102218211,0.1332568242984661088801345840693102218211,-0.2641356809703449548543119362875586375594,0.2641356809703449548543119362875586375594,-0.3903010380302908144400930723350029438734,0.3903010380302908144400930723350029438734,-0.5095014778460075222099590064317453652620,0.5095014778460075222099590064317453652620,-0.6196098757636461229481028567533940076828,0.6196098757636461229481028567533940076828,-0.7186613631319501704908248029823880642653,0.7186613631319501704908248029823880642653,-0.8048884016188398993207897547108586877584,0.8048884016188398993207897547108586877584,-0.8767523582704416229560706597112584859133,0.8767523582704416229560706597112584859133,-0.9329710868260161493736859483760781586170,0.9329710868260161493736859483760781586170,-0.9725424712181152120393790028174407780170,0.9725424712181152120393790028174407780170,-0.9947693349975521570627279288601130247116,0.9947693349975521570627279288601130247116},
    {-0.0640568928626056299791002857091370970011,0.0640568928626056299791002857091370970011,-0.1911188674736163106704367464772076345980,0.1911188674736163106704367464772076345980,-0.3150426796961633968408023065421730279922,0.3150426796961633968408023065421730279922,-0.4337935076260451272567308933503227308393,0.4337935076260451272567308933503227308393,-0.5454214713888395626995020393223967403173,0.5454214713888395626995020393223967403173,-0.6480936519369755455244330732966773211956,0.6480936519369755455244330732966773211956,-0.7401241915785543579175964623573236167431,0.7401241915785543579175964623573236167431,-0.8200019859739029470802051946520805358887,0.8200019859739029470802051946520805358887,-0.8864155270044010714869386902137193828821,0.8864155270044010714869386902137193828821,-0.9382745520027327978951348086411599069834,0.9382745520027327978951348086411599069834,-0.9747285559713094738043537290650419890881,0.9747285559713094738043537290650419890881,-0.9951872199970213106468008845695294439793,0.9951872199970213106468008845695294439793}
};

// Legendre-Gauss weights (wi values, defined by a function linked to in the Bezier primer article)
static const CGFloat FBLegendreGaussWeightValues[][24] = {{},{},
    {1.0000000000000000000000000000000000000000,1.0000000000000000000000000000000000000000},
    {0.8888888888888888395456433499930426478386,0.5555555555555555802271783250034786760807,0.5555555555555555802271783250034786760807},
    {0.6521451548625460947761212082696147263050,0.6521451548625460947761212082696147263050,0.3478548451374538497127275604725582525134,0.3478548451374538497127275604725582525134},
    {0.5688888888888888883954564334999304264784,0.4786286704993664709029133064177585765719,0.4786286704993664709029133064177585765719,0.2369268850561890848993584768322762101889,0.2369268850561890848993584768322762101889},
    {0.3607615730481386062677984227775596082211,0.3607615730481386062677984227775596082211,0.4679139345726910370615314604947343468666,0.4679139345726910370615314604947343468666,0.1713244923791703566706701167277060449123,0.1713244923791703566706701167277060449123},
    {0.4179591836734694032529091600736137479544,0.3818300505051189230876218516641529276967,0.3818300505051189230876218516641529276967,0.2797053914892766446342875497066415846348,0.2797053914892766446342875497066415846348,0.1294849661688697028960604029634851031005,0.1294849661688697028960604029634851031005},
    {0.3626837833783619902128236844873754307628,0.3626837833783619902128236844873754307628,0.3137066458778872690693617641954915598035,0.3137066458778872690693617641954915598035,0.2223810344533744820516574236535234376788,0.2223810344533744820516574236535234376788,0.1012285362903762586661571276636095717549,0.1012285362903762586661571276636095717549},
    {0.3302393550012597822629345500899944454432,0.1806481606948573959137149813614087179303,0.1806481606948573959137149813614087179303,0.0812743883615744122650426106702070683241,0.0812743883615744122650426106702070683241,0.3123470770400028628799304897256661206484,0.3123470770400028628799304897256661206484,0.2606106964029354378098446431977208703756,0.2606106964029354378098446431977208703756},
    {0.2955242247147528700246255084493895992637,0.2955242247147528700246255084493895992637,0.2692667193099963496294435572053771466017,0.2692667193099963496294435572053771466017,0.2190863625159820415877476307286997325718,0.2190863625159820415877476307286997325718,0.1494513491505805868886369580650352872908,0.1494513491505805868886369580650352872908,0.0666713443086881379917585377370414789766,0.0666713443086881379917585377370414789766},
    {0.2729250867779006162194832540990319103003,0.2628045445102466515230332788632949814200,0.2628045445102466515230332788632949814200,0.2331937645919904822378043718344997614622,0.2331937645919904822378043718344997614622,0.1862902109277342621584949711177614517510,0.1862902109277342621584949711177614517510,0.1255803694649046120535018644659430719912,0.1255803694649046120535018644659430719912,0.0556685671161736631007421749472996452823,0.0556685671161736631007421749472996452823},
    {0.2491470458134027732288728884668671526015,0.2491470458134027732288728884668671526015,0.2334925365383548057085505433860816992819,0.2334925365383548057085505433860816992819,0.2031674267230659247651658461109036579728,0.2031674267230659247651658461109036579728,0.1600783285433462210800570346691529266536,0.1600783285433462210800570346691529266536,0.1069393259953184266430881166343169752508,0.1069393259953184266430881166343169752508,0.0471753363865118277575838590109924552962,0.0471753363865118277575838590109924552962},
    {0.2325515532308738975153517003491288051009,0.2262831802628972321933531475224299356341,0.2262831802628972321933531475224299356341,0.2078160475368885096170146198346628807485,0.2078160475368885096170146198346628807485,0.1781459807619457380578609217991470359266,0.1781459807619457380578609217991470359266,0.1388735102197872495199959530509659089148,0.1388735102197872495199959530509659089148,0.0921214998377284516317686779984796885401,0.0921214998377284516317686779984796885401,0.0404840047653158771612247335269785253331,0.0404840047653158771612247335269785253331},
    {0.2152638534631577948985636794532183557749,0.2152638534631577948985636794532183557749,0.2051984637212956041896205761076998896897,0.2051984637212956041896205761076998896897,0.1855383974779378219999159682629397138953,0.1855383974779378219999159682629397138953,0.1572031671581935463599677404999965801835,0.1572031671581935463599677404999965801835,0.1215185706879031851679329179205524269491,0.1215185706879031851679329179205524269491,0.0801580871597602079292599341897584963590,0.0801580871597602079292599341897584963590,0.0351194603317518602714208952875196700916,0.0351194603317518602714208952875196700916},
    {0.2025782419255612865072180284187197685242,0.1984314853271115786093048427574103698134,0.1984314853271115786093048427574103698134,0.1861610000155622113293674146916600875556,0.1861610000155622113293674146916600875556,0.1662692058169939202105780395868350751698,0.1662692058169939202105780395868350751698,0.1395706779261543240000520427201990969479,0.1395706779261543240000520427201990969479,0.1071592204671719394948325998484506271780,0.1071592204671719394948325998484506271780,0.0703660474881081243747615872052847407758,0.0703660474881081243747615872052847407758,0.0307532419961172691358353148416426847689,0.0307532419961172691358353148416426847689},
    {0.1894506104550685021692402187909465283155,0.1894506104550685021692402187909465283155,0.1826034150449235837765371570640127174556,0.1826034150449235837765371570640127174556,0.1691565193950025358660127494658809155226,0.1691565193950025358660127494658809155226,0.1495959888165767359691216142891789786518,0.1495959888165767359691216142891789786518,0.1246289712555338768940060845125117339194,0.1246289712555338768940060845125117339194,0.0951585116824927856882254673109855502844,0.0951585116824927856882254673109855502844,0.0622535239386478936318702892549481475726,0.0622535239386478936318702892549481475726,0.0271524594117540964133272751723779947497,0.0271524594117540964133272751723779947497},
    {0.1794464703562065333031227964966092258692,0.1765627053669926449508409405098063871264,0.1765627053669926449508409405098063871264,0.1680041021564500358653759803928551264107,0.1680041021564500358653759803928551264107,0.1540457610768102836296122859494062140584,0.1540457610768102836296122859494062140584,0.1351363684685254751283167706787935458124,0.1351363684685254751283167706787935458124,0.1118838471934039680011352402289048768580,0.1118838471934039680011352402289048768580,0.0850361483171791776580761279547004960477,0.0850361483171791776580761279547004960477,0.0554595293739872027827253475606994470581,0.0554595293739872027827253475606994470581,0.0241483028685479314545681006620725383982,0.0241483028685479314545681006620725383982},
    {0.1691423829631436004383715498988749459386,0.1691423829631436004383715498988749459386,0.1642764837458327298325144738555536605418,0.1642764837458327298325144738555536605418,0.1546846751262652419622867228099494241178,0.1546846751262652419622867228099494241178,0.1406429146706506538855308008351130411029,0.1406429146706506538855308008351130411029,0.1225552067114784593471199514169711619616,0.1225552067114784593471199514169711619616,0.1009420441062871681703327908508072141558,0.1009420441062871681703327908508072141558,0.0764257302548890515847546112127020023763,0.0764257302548890515847546112127020023763,0.0497145488949697969549568199454370187595,0.0497145488949697969549568199454370187595,0.0216160135264833117019200869890482863411,0.0216160135264833117019200869890482863411},
    {0.1610544498487836984068621859478298574686,0.1589688433939543399375793342187535017729,0.1589688433939543399375793342187535017729,0.1527660420658596696075193221986410208046,0.1527660420658596696075193221986410208046,0.1426067021736066031678547005867585539818,0.1426067021736066031678547005867585539818,0.1287539625393362141547726196222356520593,0.1287539625393362141547726196222356520593,0.1115666455473339896409257221421285066754,0.1115666455473339896409257221421285066754,0.0914900216224499990280705219447554554790,0.0914900216224499990280705219447554554790,0.0690445427376412262931992813719261903316,0.0690445427376412262931992813719261903316,0.0448142267656995996194524423117400147021,0.0448142267656995996194524423117400147021,0.0194617882297264781221723950466184760444,0.0194617882297264781221723950466184760444},
    {0.1527533871307258372951309866039082407951,0.1527533871307258372951309866039082407951,0.1491729864726037413369397199858212843537,0.1491729864726037413369397199858212843537,0.1420961093183820411756101975697674788535,0.1420961093183820411756101975697674788535,0.1316886384491766370796739238357986323535,0.1316886384491766370796739238357986323535,0.1181945319615184120110029653005767613649,0.1181945319615184120110029653005767613649,0.1019301198172404415709380032240005675703,0.1019301198172404415709380032240005675703,0.0832767415767047547436874310733401216567,0.0832767415767047547436874310733401216567,0.0626720483341090678353069165495980996639,0.0626720483341090678353069165495980996639,0.0406014298003869386621822457072994438931,0.0406014298003869386621822457072994438931,0.0176140071391521178811867542890468030237,0.0176140071391521178811867542890468030237},
    {0.1460811336496904144777175815761438570917,0.1445244039899700461138110085812513716519,0.1445244039899700461138110085812513716519,0.1398873947910731496691028041823301464319,0.1398873947910731496691028041823301464319,0.1322689386333374683690777828815043903887,0.1322689386333374683690777828815043903887,0.1218314160537285334440227302366110961884,0.1218314160537285334440227302366110961884,0.1087972991671483785625085261017375160009,0.1087972991671483785625085261017375160009,0.0934444234560338621298214434318651910871,0.0934444234560338621298214434318651910871,0.0761001136283793039316591944043466355652,0.0761001136283793039316591944043466355652,0.0571344254268572049326735395879950374365,0.0571344254268572049326735395879950374365,0.0369537897708524937234741969405149575323,0.0369537897708524937234741969405149575323,0.0160172282577743345377552230957007850520,0.0160172282577743345377552230957007850520},
    {0.1392518728556319806966001806358690373600,0.1392518728556319806966001806358690373600,0.1365414983460151721050834794368711300194,0.1365414983460151721050834794368711300194,0.1311735047870623838139891859100316651165,0.1311735047870623838139891859100316651165,0.1232523768105124178928733158500108402222,0.1232523768105124178928733158500108402222,0.1129322960805392156435900119504367467016,0.1129322960805392156435900119504367467016,0.1004141444428809648581335522976587526500,0.1004141444428809648581335522976587526500,0.0859416062170677286236042391465161927044,0.0859416062170677286236042391465161927044,0.0697964684245204886048341563764552120119,0.0697964684245204886048341563764552120119,0.0522933351526832859712534684604179346934,0.0522933351526832859712534684604179346934,0.0337749015848141515006020085820637177676,0.0337749015848141515006020085820637177676,0.0146279952982721998810955454928262042813,0.0146279952982721998810955454928262042813},
    {0.1336545721861061852830943053049850277603,0.1324620394046966131984532921705977059901,0.1324620394046966131984532921705977059901,0.1289057221880821613169132433540653437376,0.1289057221880821613169132433540653437376,0.1230490843067295336776822978208656422794,0.1230490843067295336776822978208656422794,0.1149966402224113642960290349037677515298,0.1149966402224113642960290349037677515298,0.1048920914645414120824895576333801727742,0.1048920914645414120824895576333801727742,0.0929157660600351542612429511791560798883,0.0929157660600351542612429511791560798883,0.0792814117767189491248203125906002242118,0.0792814117767189491248203125906002242118,0.0642324214085258499151720457120973151177,0.0642324214085258499151720457120973151177,0.0480376717310846690356385124687221832573,0.0480376717310846690356385124687221832573,0.0309880058569794447631551292943186126649,0.0309880058569794447631551292943186126649,0.0134118594871417712993677540112003043760,0.0134118594871417712993677540112003043760},
    {0.1279381953467521593204025975865079089999,0.1279381953467521593204025975865079089999,0.1258374563468283025002847352880053222179,0.1258374563468283025002847352880053222179,0.1216704729278033914052770114722079597414,0.1216704729278033914052770114722079597414,0.1155056680537255991980671865348995197564,0.1155056680537255991980671865348995197564,0.1074442701159656343712356374453520402312,0.1074442701159656343712356374453520402312,0.0976186521041138843823858906034729443491,0.0976186521041138843823858906034729443491,0.0861901615319532743431096832864568568766,0.0861901615319532743431096832864568568766,0.0733464814110802998392557583429152145982,0.0733464814110802998392557583429152145982,0.0592985849154367833380163688161701429635,0.0592985849154367833380163688161701429635,0.0442774388174198077483545432642131345347,0.0442774388174198077483545432642131345347,0.0285313886289336633705904233693217975087,0.0285313886289336633705904233693217975087,0.0123412297999872001830201639904771582223,0.0123412297999872001830201639904771582223}
};

static CGFloat FBGaussQuadratureBaseForCubic(CGFloat t, CGFloat p1, CGFloat p2, CGFloat p3, CGFloat p4)
{
    float t1 = -3.0 * p1 + 9.0 * p2 - 9.0 * p3 + 3.0 * p4;
    float t2 = t * t1 + 6.0 * p1 - 12.0 * p2 + 6.0 * p3;
    return t * t2 - 3.0 * p1 + 3.0 * p2;
    //return t * (t * (-3 * p1 + 9 * p2 - 9 * p3 + 3 * p4) + 6 * p1 + 12 * p2 + 3 * p3) - 3 * p1 + 3 * p2;
}

static CGFloat FBGaussQuadratureFOfTForCubic(CGFloat t, CGPoint p1, CGPoint p2, CGPoint p3, CGPoint p4)
{
    CGFloat baseX = FBGaussQuadratureBaseForCubic(t, p1.x, p2.x, p3.x, p4.x);
    CGFloat baseY = FBGaussQuadratureBaseForCubic(t, p1.y, p2.y, p3.y, p4.y);
    
    return sqrtf(baseX * baseX + baseY * baseY);
}

static CGFloat FBGaussQuadratureComputeCurveLengthForCubic(CGFloat z, NSUInteger steps, CGPoint p1, CGPoint p2, CGPoint p3, CGPoint p4)
{
    CGFloat z2 = z / 2.0;
    CGFloat sum = 0.0;
    for (NSUInteger i = 0; i < steps; i++) {
        CGFloat correctedT = z2 * FBLegendreGaussAbscissaeValues[steps][i] + z2;
        sum += FBLegendreGaussWeightValues[steps][i] * FBGaussQuadratureFOfTForCubic(correctedT, p1, p2, p3, p4);
    }
    return z2 * sum;
}

//////////////////////////////////////////////////////////////////////////////////
// FBBezierCurve
//
// The main purpose of this class is to compute the intersections of two bezier
//  curves. It does this using the bezier clipping algorithm, described in
//  "Curve intersection using Bezier clipping" by TW Sederberg and T Nishita.
//  http://cagd.cs.byu.edu/~tom/papers/bezclip.pdf
//
@interface FBBezierCurve ()

- (FBNormalizedLine) regularFatLineBounds:(FBRange *)range;
- (FBNormalizedLine) perpendicularFatLineBounds:(FBRange *)range;

- (FBRange) clipWithFatLine:(FBNormalizedLine)fatLine bounds:(FBRange)bounds;
- (NSArray *) splitCurveAtParameter:(CGFloat)t;
- (NSArray *) convexHull;
- (FBBezierCurve *) bezierClipWithBezierCurve:(FBBezierCurve *)curve original:(FBBezierCurve *)originalCurve rangeOfOriginal:(FBRange *)originalRange intersects:(BOOL *)intersects;
- (NSArray *) intersectionsWithBezierCurve:(FBBezierCurve *)curve usRange:(FBRange *)usRange themRange:(FBRange *)themRange originalUs:(FBBezierCurve *)originalUs originalThem:(FBBezierCurve *)originalThem overlapRange:(FBBezierIntersectRange **)intersectRange depth:(NSUInteger)depth;
- (CGFloat) refineParameter:(CGFloat)parameter forPoint:(CGPoint)point;

@property (readonly, getter = isPoint) BOOL point;

@end

@implementation FBBezierCurve

@synthesize endPoint1=_endPoint1;
@synthesize controlPoint1=_controlPoint1;
@synthesize controlPoint2=_controlPoint2;
@synthesize endPoint2=_endPoint2;
@synthesize isStraightLine = _isStraightLine;

+ (NSArray *) bezierCurvesFromBezierPath:(UIBezierPath *)path
{
    // Helper method to easily convert a bezier path into an array of FBBezierCurves. Very straight forward,
    //  only lines are a special case.
    
    CGPoint lastPoint = CGPointZero;
    NSMutableArray *bezierCurves = [NSMutableArray arrayWithCapacity:[path elementCount]];
    
    for (NSUInteger i = 0; i < [path elementCount]; i++) {
        UIBezierElement element = [path fb_elementAtIndex:i];
        
        switch (element.kind) {
                
            case kCGPathElementMoveToPoint:
                lastPoint = element.point;
                break;
                
            case kCGPathElementAddLineToPoint: {
                // Convert lines to bezier curves as well. Just set control point to be in the line formed
                //  by the end points
                [bezierCurves addObject:[FBBezierCurve bezierCurveWithLineStartPoint:lastPoint endPoint:element.point]];
                
                lastPoint = element.point;
                break;
            }
                
            case kCGPathElementAddCurveToPoint:
                [bezierCurves addObject:[FBBezierCurve bezierCurveWithEndPoint1:lastPoint controlPoint1:element.controlPoints[0] controlPoint2:element.controlPoints[1] endPoint2:element.point]];
                
                lastPoint = element.point;
                break;
                
            case kCGPathElementCloseSubpath:
                lastPoint = CGPointZero;
                break;
            default:
                break;
        }
    }
    
    return bezierCurves;
}

+ (id) bezierCurveWithLineStartPoint:(CGPoint)startPoint endPoint:(CGPoint)endPoint
{
    return [[[FBBezierCurve alloc] initWithLineStartPoint:startPoint endPoint:endPoint] autorelease];
}

+ (id) bezierCurveWithEndPoint1:(CGPoint)endPoint1 controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2 endPoint2:(CGPoint)endPoint2
{
    return [[[FBBezierCurve alloc] initWithEndPoint1:endPoint1 controlPoint1:controlPoint1 controlPoint2:controlPoint2 endPoint2:endPoint2] autorelease];
}

- (id) initWithEndPoint1:(CGPoint)endPoint1 controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2 endPoint2:(CGPoint)endPoint2
{
    self = [super init];
    
    if ( self != nil ) {
        _endPoint1 = endPoint1;
        _controlPoint1 = controlPoint1;
        _controlPoint2 = controlPoint2;
        _endPoint2 = endPoint2;
    }
    
    return self;
}

- (id) initWithLineStartPoint:(CGPoint)startPoint endPoint:(CGPoint)endPoint
{
    self = [super init];
    
    if ( self != nil ) {
        // Convert the line into a bezier curve to keep our intersection algorithm general (i.e. only
        //  has to deal with curves, not lines). As long as the control points are colinear with the
        //  end points, it'll be a line. But for consistency sake, we put the control points inside
        //  the end points, 1/3 of the total distance away from their respective end point.
        CGFloat distance = FBDistanceBetweenPoints(startPoint, endPoint);
        CGPoint leftTangent = FBNormalizePoint(FBSubtractPoint(endPoint, startPoint));
        _controlPoint1 = FBAddPoint(startPoint, FBUnitScalePoint(leftTangent, distance / 3.0));
        _controlPoint2 = FBAddPoint(startPoint, FBUnitScalePoint(leftTangent, 2.0 * distance / 3.0));
        _endPoint1 = startPoint;
        _endPoint2 = endPoint;
		
		// GPC: flag that this is a straight line. Later, we can use this to restore the segment to a lineTo: rather than a curveTo: element.
		_isStraightLine = YES;
    }
    
    return self;
}

- (void)dealloc
{
    [super dealloc];
}

- (BOOL) isEqual:(id)object
{
    if ( ![object isKindOfClass:[FBBezierCurve class]] )
        return NO;
    
    FBBezierCurve *other = object;
    if ( self.isPoint || other.isPoint )
        return NO;
    if ( self.isStraightLine != other.isStraightLine )
        return NO;
    
    if ( self.isStraightLine )
        return FBArePointsClose(self.endPoint1, other.endPoint1) && FBArePointsClose(self.endPoint2, other.endPoint2);
    return FBArePointsClose(self.endPoint1, other.endPoint1) && FBArePointsClose(self.controlPoint1, other.controlPoint1) && FBArePointsClose(self.controlPoint2, other.controlPoint2) && FBArePointsClose(self.endPoint2, other.endPoint2);
}

- (NSArray *) intersectionsWithBezierCurve:(FBBezierCurve *)curve
{
    return [self intersectionsWithBezierCurve:curve overlapRange:nil];
}

- (NSArray *) intersectionsWithBezierCurve:(FBBezierCurve *)curve overlapRange:(FBBezierIntersectRange **)intersectRange
{
    FBRange usRange = FBRangeMake(0, 1);
    FBRange themRange = FBRangeMake(0, 1);
    return [self intersectionsWithBezierCurve:curve usRange:&usRange themRange:&themRange originalUs:self originalThem:curve overlapRange:intersectRange depth:0];
}

-(BOOL) rect:(CGRect)rect isNear:(CGPoint)point{
    return point.x + 10 > rect.origin.x &&
    point.x - 10 < rect.origin.x + rect.size.width &&
    point.y + 10 > rect.origin.y &&
    point.y - 10 < rect.origin.y + rect.size.height;
}

- (NSArray *) intersectionsWithBezierCurve:(FBBezierCurve *)curve usRange:(FBRange *)usRange themRange:(FBRange *)themRange originalUs:(FBBezierCurve *)originalUs originalThem:(FBBezierCurve *)originalThem overlapRange:(FBBezierIntersectRange **)intersectRange depth:(NSUInteger)depth
{
    // This is the main work loop. At a high level this method sits in a loop and removes sections (ranges) of the two bezier curves that it knows
    //  don't intersect (how it knows that is covered in the appropriate method). The idea is to whittle the curves down to the point where they
    //  do intersect. When the range where they intersect converges (i.e. matches to 6 decimal places) or there are more than 500 attempts, the loop
    //  stops. A special case is when we're not able to remove at least 20% of the curves on a given interation. In that case we assume there are likely
    //  multiple intersections, so we divide one of curves in half, and recurse on the two halves.
    
    static const NSUInteger places = 6; // How many decimals place to calculate the solution out to
    static const NSUInteger maxIterations = 500; // how many iterations to allow before we just give up
    static const NSUInteger maxDepth = 10; // how many recursive calls to allow before we just give up
    static const CGFloat minimumChangeNeeded = 0.20; // how much to clip off for a given iteration minimum before we subdivide the curve

    FBBezierCurve *us = self; // us is self, but clipped down to where the intersection is
    FBBezierCurve *them = curve; // them is the other curve we're intersecting with, but clipped down to where the intersection is
    FBBezierCurve *nonpointUs = us;
    FBBezierCurve *nonpointThem = them;
    
    // Don't check for convergence until we actually see if we intersect or not. i.e. Make sure we go through at least once, otherwise the results
    //  don't mean anything. Be sure to stop as soon as either range converges, otherwise calculations for the other range goes funky because one
    //  curve is essentially a point.
    NSUInteger iterations = 0;
    while ( iterations < maxIterations && ((iterations == 0) || (!FBRangeHasConverged(*usRange, places) || !FBRangeHasConverged(*themRange, places))) ) {
        // Remember what the current range is so we can calculate how much it changed later
        FBRange previousUsRange = *usRange;
        FBRange previousThemRange = *themRange;
        
        // Remove the range from ourselves that doesn't intersect with them. If the other curve is already a point, use the previous iteration's
        //  copy of them so calculations still work.
        BOOL intersects = NO;
        if ( !them.isPoint )
            nonpointThem = them;
        us = [nonpointUs bezierClipWithBezierCurve:nonpointThem original:originalUs rangeOfOriginal:usRange intersects:&intersects];
        if ( !intersects )
            return [NSArray array]; // If they don't intersect at all stop now
        if (us.isPoint || them.isPoint)
            break;
        
        // Remove the range of them that doesn't intersect with us
        if ( !us.isPoint )
            nonpointUs = us;
        them = [nonpointThem bezierClipWithBezierCurve:nonpointUs original:originalThem rangeOfOriginal:themRange intersects:&intersects];
        
        if ( !intersects )
            return [NSArray array];  // If they don't intersect at all stop now
        if (us.isPoint || them.isPoint)
            break;
        
        // See if either of curves ranges is reduced by less than 20%.
        CGFloat percentChangeInUs = (FBRangeGetSize(previousUsRange) - FBRangeGetSize(*usRange)) / FBRangeGetSize(previousUsRange);
        CGFloat percentChangeInThem = (FBRangeGetSize(previousThemRange) - FBRangeGetSize(*themRange)) / FBRangeGetSize(previousThemRange);
        BOOL didNotSplit = NO;
        if ( percentChangeInUs < minimumChangeNeeded && percentChangeInThem < minimumChangeNeeded ) {
            // We're not converging fast enough, likely because there are multiple intersections here. 
            //  Or the curves are the same, check for that first
            if ( [us isEqual:them] ) {
                if ( intersectRange != nil ) {
                    *intersectRange = [FBBezierIntersectRange intersectRangeWithCurve1:originalUs parameterRange1:*usRange curve2:originalThem parameterRange2:*themRange reversed:NO];
                }
                return [NSArray array];
            }
            if ( [us isEqual:[them reversedCurve]] ) {
                if ( intersectRange != nil ) {
                    *intersectRange = [FBBezierIntersectRange intersectRangeWithCurve1:originalUs parameterRange1:*usRange curve2:originalThem parameterRange2:*themRange reversed:YES];
                }
                return [NSArray array];
            }

            // Divide and conquer. Divide the longer curve in half, and recurse
            if ( FBRangeGetSize(*usRange) > FBRangeGetSize(*themRange) ) {
                // Since our remaining range is longer, split the remains of us in half at the midway point
                FBRange usRange1 = FBRangeMake(usRange->minimum, (usRange->minimum + usRange->maximum) / 2.0);
                FBBezierCurve *us1 = [originalUs subcurveWithRange:usRange1];
                FBRange themRangeCopy1 = *themRange; // make a local copy because it'll get modified when we recurse

                FBRange usRange2 = FBRangeMake((usRange->minimum + usRange->maximum) / 2.0, usRange->maximum);
                FBBezierCurve *us2 = [originalUs subcurveWithRange:usRange2];
                FBRange themRangeCopy2 = *themRange; // make a local copy because it'll get modified when we recurse
                
                BOOL range1ConvergedAlready = FBRangeHasConverged(usRange1, places) && FBRangeHasConverged(*themRange, places);
                BOOL range2ConvergedAlready = FBRangeHasConverged(usRange2, places) && FBRangeHasConverged(*themRange, places);
                
                if ( !range1ConvergedAlready && !range2ConvergedAlready && depth < maxDepth ) {
                    // Compute the intersections between the two halves of us and them
                    NSArray *intersections1 = [us1 intersectionsWithBezierCurve:them usRange:&usRange1 themRange:&themRangeCopy1 originalUs:originalUs originalThem:originalThem overlapRange:intersectRange depth:depth + 1];
                    NSArray *intersections2 = [us2 intersectionsWithBezierCurve:them usRange:&usRange2 themRange:&themRangeCopy2 originalUs:originalUs originalThem:originalThem overlapRange:intersectRange depth:depth + 1];
                    
                    return [intersections1 arrayByAddingObjectsFromArray:intersections2];
                } else
                    didNotSplit = YES;
            } else {
                // Since their remaining range is longer, split the remains of them in half at the midway point
                FBRange themRange1 = FBRangeMake(themRange->minimum, (themRange->minimum + themRange->maximum) / 2.0);
                FBBezierCurve *them1 = [originalThem subcurveWithRange:themRange1];
                FBRange usRangeCopy1 = *usRange;  // make a local copy because it'll get modified when we recurse

                FBRange themRange2 = FBRangeMake((themRange->minimum + themRange->maximum) / 2.0, themRange->maximum);
                FBBezierCurve *them2 = [originalThem subcurveWithRange:themRange2];
                FBRange usRangeCopy2 = *usRange;  // make a local copy because it'll get modified when we recurse

                BOOL range1ConvergedAlready = FBRangeHasConverged(themRange1, places) && FBRangeHasConverged(*usRange, places);
                BOOL range2ConvergedAlready = FBRangeHasConverged(themRange2, places) && FBRangeHasConverged(*usRange, places);

                if ( !range1ConvergedAlready && !range2ConvergedAlready && depth < maxDepth ) {
                    // Compute the intersections between the two halves of them and us
                    NSArray *intersections1 = [us intersectionsWithBezierCurve:them1 usRange:&usRangeCopy1 themRange:&themRange1 originalUs:originalUs originalThem:originalThem overlapRange:intersectRange depth:depth + 1];
                    NSArray *intersections2 = [us intersectionsWithBezierCurve:them2 usRange:&usRangeCopy2 themRange:&themRange2 originalUs:originalUs originalThem:originalThem overlapRange:intersectRange depth:depth + 1];
                    
                    return [intersections1 arrayByAddingObjectsFromArray:intersections2];
                } else 
                    didNotSplit = YES;
            }
            
            if ( didNotSplit && (FBRangeGetSize(previousUsRange) - FBRangeGetSize(*usRange) == 0) && (FBRangeGetSize(previousThemRange) - FBRangeGetSize(*themRange) == 0) ) {
                // We're not converging at _all_ and we can't split, so we need to bail out. 
                return [NSArray array]; // no intersections
            }
        }
        
        iterations++;
    }
    
    
    // It's possible that one of the curves has converged, but the other hasn't. Since the math becomes wonky once a curve becomes a point,
    //  the loop stops as soon as either curve converges. However for our purposes we need _both_ curves to converge; that is we need
    //  the parameter for each curve where they intersect. Fortunately, since one curve did converge we know the 2D point where they converge,
    //  plus we have a reasonable approximation for the parameter for the curve that didn't. That means we can use Newton's method to refine
    //  the parameter of the curve that did't converge.
    BOOL hadConverged = YES;
    if ( !FBRangeHasConverged(*usRange, places) || !FBRangeHasConverged(*themRange, places) ) {
        // We bail out of the main loop as soon as we know things intersect, but before the math falls apart. Unfortunately sometimes this
        //  means we don't always get the best estimate of the parameters. Below we fall back to Netwon's method, but it's accuracy is 
        //  dependant on our previous calculations. So here assume things intersect and just try to tighten up the parameters. If the
        //  math falls apart because everything's a point, that's OK since we already have a "reasonable" estimation of the parameters.
        for (int i = 0; i < 3; i++) {
            BOOL intersects = NO;
            us = [us bezierClipWithBezierCurve:them original:originalUs rangeOfOriginal:usRange intersects:&intersects];  
            if ( !intersects )
                us = [nonpointUs bezierClipWithBezierCurve:nonpointThem original:originalUs rangeOfOriginal:usRange intersects:&intersects];
            them = [them bezierClipWithBezierCurve:us original:originalThem rangeOfOriginal:themRange intersects:&intersects];
            if ( !intersects )
                them = [nonpointThem bezierClipWithBezierCurve:nonpointUs original:originalThem rangeOfOriginal:themRange intersects:&intersects];
            if ( !them.isPoint )
                nonpointThem = them;
            if ( !us.isPoint )
                nonpointUs = us;
        }
    }
    if ( FBRangeHasConverged(*usRange, places) && !FBRangeHasConverged(*themRange, places) ) {
        // Refine the them range since it didn't converge
        CGPoint intersectionPoint = [originalUs pointAtParameter:FBRangeAverage(*usRange) leftBezierCurve:nil rightBezierCurve:nil];
        CGFloat refinedParameter = FBRangeAverage(*themRange); // Although the range didn't converge, it should be a reasonable approximation which is all Newton needs
        for (NSUInteger i = 0; i < 3; i++) {
            refinedParameter = [originalThem refineParameter:refinedParameter forPoint:intersectionPoint];
            refinedParameter = MIN(themRange->maximum, MAX(themRange->minimum, refinedParameter));
        }
        themRange->minimum = refinedParameter;
        themRange->maximum = refinedParameter;
        hadConverged = NO;
    } else if ( !FBRangeHasConverged(*usRange, places) && FBRangeHasConverged(*themRange, places) ) {
        // Refine the us range since it didn't converge
        CGPoint intersectionPoint = [originalThem pointAtParameter:FBRangeAverage(*themRange) leftBezierCurve:nil rightBezierCurve:nil];
        CGFloat refinedParameter = FBRangeAverage(*usRange); // Although the range didn't converge, it should be a reasonable approximation which is all Newton needs
        for (NSUInteger i = 0; i < 3; i++) {
            refinedParameter = [originalUs refineParameter:refinedParameter forPoint:intersectionPoint];
            refinedParameter = MIN(usRange->maximum, MAX(usRange->minimum, refinedParameter));
        }
        usRange->minimum = refinedParameter;
        usRange->maximum = refinedParameter; 
        hadConverged = NO;
    }
    if ( !hadConverged ) {
        // Since one of them didn't converge, we need to make sure they actually intersect. Compute the point from both and compare
        CGPoint intersectionPoint = [originalUs pointAtParameter:FBRangeAverage(*usRange) leftBezierCurve:nil rightBezierCurve:nil];
        CGPoint checkPoint = [originalThem pointAtParameter:FBRangeAverage(*themRange) leftBezierCurve:nil rightBezierCurve:nil];
        if ( !FBArePointsCloseWithOptions(intersectionPoint, checkPoint, 1e-3) )
            return [NSArray array];
    }
    // Return the final intersection, which we represent by the original curves and the parameters where they intersect. The parameter values are useful
    //  later in the boolean operations, plus it allows us to do lazy calculations.
    return [NSArray arrayWithObject:[FBBezierIntersection intersectionWithCurve1:originalUs parameter1:FBRangeAverage(*usRange) curve2:originalThem parameter2:FBRangeAverage(*themRange)]];
}


- (FBBezierCurve *) bezierClipWithBezierCurve:(FBBezierCurve *)curve original:(FBBezierCurve *)originalCurve rangeOfOriginal:(FBRange *)originalRange intersects:(BOOL *)intersects
{
    // This method does the clipping of self. It removes the parts of self that we can determine don't intersect
    //  with curve. It'll return the clipped version of self, update originalRange which corresponds to the range
    //  on the original curve that the return value represents. Finally, it'll set the intersects out parameter
    //  to yes or no depending on if the curves intersect or not.
    
    // Clipping works as follows:
    //  Draw a line through the two endpoints of the other curve, which we'll call the fat line. Measure the 
    //  signed distance between the control points on the other curve and the fat line. The distance from the line
    //  will give us the fat line bounds. Any part of our curve that lies further away from the fat line than the 
    //  fat line bounds we know can't intersect with the other curve, and thus can be removed.
    
    // We actually use two different fat lines. The first one uses the end points of the other curve, and the second
    //  one is perpendicular to the first. Most of the time, the first fat line will clip off more, but sometimes the
    //  second proves to be a better fat line in that it clips off more. We use both in order to converge more quickly.
    
    // Compute the regular fat line using the end points, then compute the range that could still possibly intersect
    //  with the other curve
    FBRange fatLineBounds = {};
    FBNormalizedLine fatLine = [curve regularFatLineBounds:&fatLineBounds];
    
    
    FBRange regularClippedRange = [self clipWithFatLine:fatLine bounds:fatLineBounds];
    // A range of [1, 0] is a special sentinel value meaning "they don't intersect". If they don't, bail early to save time
    if ( regularClippedRange.minimum == 1.0 && regularClippedRange.maximum == 0.0 ) {
        *intersects = NO;
        return self;
    }
    
    // Just in case the regular fat line isn't good enough, try the perpendicular one
    FBRange perpendicularLineBounds = {};
    FBNormalizedLine perpendicularLine = [curve perpendicularFatLineBounds:&perpendicularLineBounds];
    FBRange perpendicularClippedRange = [self clipWithFatLine:perpendicularLine bounds:perpendicularLineBounds];
    if ( perpendicularClippedRange.minimum == 1.0 && perpendicularClippedRange.maximum == 0.0 ) {
        *intersects = NO;
        return self;
    }
    
    // Combine to form Voltron. Take the intersection of the regular fat line range and the perpendicular one.
    FBRange clippedRange = FBRangeMake(MAX(regularClippedRange.minimum, perpendicularClippedRange.minimum), MIN(regularClippedRange.maximum, perpendicularClippedRange.maximum));
    
    // Right now the clipped range is relative to ourself, not the original curve. So map the newly clipped range onto the original range
    FBRange newRange = FBRangeMake(FBRangeScaleNormalizedValue(*originalRange, clippedRange.minimum), FBRangeScaleNormalizedValue(*originalRange, clippedRange.maximum));    
    *originalRange = newRange;
    *intersects = YES;
    
    // Actually divide the curve, but be sure to use the original curve. This helps with errors building up.
    return [originalCurve subcurveWithRange:*originalRange];
}

- (FBNormalizedLine) regularFatLineBounds:(FBRange *)range
{
    // Create the fat line based on the end points
    FBNormalizedLine line = FBNormalizedLineMake(_endPoint1, _endPoint2);
    
    // Compute the bounds of the fat line. The fat line bounds should entirely encompass the
    //  bezier curve. Since we know the convex hull entirely compasses the curve, just take
    //  all four points that define this cubic bezier curve. Compute the signed distances of
    //  each of the end and control points from the fat line, and that will give us the bounds.
    
    // In this case, we know that the end points are on the line, thus their distances will be 0.
    //  So we can skip computing those and just use 0.
    CGFloat controlPoint1Distance = FBNormalizedLineDistanceFromPoint(line, _controlPoint1);
    CGFloat controlPoint2Distance = FBNormalizedLineDistanceFromPoint(line, _controlPoint2);    
    CGFloat min = MIN(controlPoint1Distance, MIN(controlPoint2Distance, 0.0));
    CGFloat max = MAX(controlPoint1Distance, MAX(controlPoint2Distance, 0.0));
        
    *range = FBRangeMake(min, max);
    
    return line;
}

- (FBNormalizedLine) perpendicularFatLineBounds:(FBRange *)range
{
    // Create a fat line that's perpendicular to the line created by the two end points.
    CGPoint normal = FBLineNormal(_endPoint1, _endPoint2);
    CGPoint startPoint = FBLineMidpoint(_endPoint1, _endPoint2);
    CGPoint endPoint = FBAddPoint(startPoint, normal);
    FBNormalizedLine line = FBNormalizedLineMake(startPoint, endPoint);
    
    // Compute the bounds of the fat line. The fat line bounds should entirely encompass the
    //  bezier curve. Since we know the convex hull entirely compasses the curve, just take
    //  all four points that define this cubic bezier curve. Compute the signed distances of
    //  each of the end and control points from the fat line, and that will give us the bounds.
    CGFloat controlPoint1Distance = FBNormalizedLineDistanceFromPoint(line, _controlPoint1);
    CGFloat controlPoint2Distance = FBNormalizedLineDistanceFromPoint(line, _controlPoint2);
    CGFloat point1Distance = FBNormalizedLineDistanceFromPoint(line, _endPoint1);
    CGFloat point2Distance = FBNormalizedLineDistanceFromPoint(line, _endPoint2);

    CGFloat min = MIN(controlPoint1Distance, MIN(controlPoint2Distance, MIN(point1Distance, point2Distance)));
    CGFloat max = MAX(controlPoint1Distance, MAX(controlPoint2Distance, MAX(point1Distance, point2Distance)));
    
    *range = FBRangeMake(min, max);
    
    return line;
}

- (FBRange) clipWithFatLine:(FBNormalizedLine)fatLine bounds:(FBRange)bounds
{
    // This method computes the range of self that could possibly intersect with the fat line passed in (and thus with the curve enclosed by the fat line).
    //  To do that, we first compute the signed distance of all our points (end and control) from the fat line, and map those onto a bezier curve at
    //  evenly spaced intervals from [0..1]. The parts of the distance bezier that fall inside of the fat line bounds, correspond to the parts of ourself
    //  that could potentially intersect with the other curve. Ideally, we'd calculate where the distance bezier intersected the horizontal lines representing
    //  the fat line bounds. However, computing those intersections is hard and costly. So instead we'll compute the convex hull, and intersect those lines
    //  with the fat line bounds. The intersection with the lowest x coordinate will be the minimum, and the intersection with the highest x coordinate will
    //  be the maximum.
    
    // The convex hull (for cubic beziers) is the four points that define the curve. A useful property of the convex hull is that the entire curve lies
    //  inside of it.
    
    // First calculate bezier curve points distance from the fat line that's clipping us
    FBBezierCurve *distanceBezier = [FBBezierCurve bezierCurveWithEndPoint1:CGPointMake(0, FBNormalizedLineDistanceFromPoint(fatLine, _endPoint1)) controlPoint1:CGPointMake(1.0/3.0, FBNormalizedLineDistanceFromPoint(fatLine, _controlPoint1)) controlPoint2:CGPointMake(2.0/3.0, FBNormalizedLineDistanceFromPoint(fatLine, _controlPoint2)) endPoint2:CGPointMake(1.0, FBNormalizedLineDistanceFromPoint(fatLine, _endPoint2))];
    NSArray *convexHull = [distanceBezier convexHull]; // the convex hull can be anywhere from 2 to 4 points.
    
    // Find intersections of convex hull with the fat line bounds
    FBRange range = FBRangeMake(1.0, 0.0);
    for (NSUInteger i = 0; i < [convexHull count]; i++) {
        // Pull out the current line on the convex hull
        NSUInteger indexOfNext = i < ([convexHull count] - 1) ? i + 1 : 0;
        CGPoint startPoint = [[convexHull objectAtIndex:i] CGPointValue];
        CGPoint endPoint = [[convexHull objectAtIndex:indexOfNext] CGPointValue];
        CGPoint intersectionPoint = CGPointZero;
        
        // See if the segment of the convex hull intersects with the minimum fat line bounds
        if ( LineIntersectsHorizontalLine(startPoint, endPoint, bounds.minimum, &intersectionPoint) ) {
            if ( intersectionPoint.x < range.minimum )
                range.minimum = intersectionPoint.x;
            if ( intersectionPoint.x > range.maximum )
                range.maximum = intersectionPoint.x;
        }
        // This is a very special case that I really wish I could get rid of. If perfectly horizontal and perfectly vertical lines intersect at both of their end points,
        //  the convex hull becomes a horizontal line on top of the minimum and maximum lines, which makes the line intersection calculation wonky. At this point, we
        //  throw our hands up and just say "we don't know where in here they intersect". If we don't do this, we end up saying they don't intersect at all, which could
        //  be wrong.
        if ( [convexHull count] == 2 && FBAreValuesClose(startPoint.y, endPoint.y) && FBAreValuesClose(startPoint.y, bounds.minimum) && !FBAreValuesClose(bounds.minimum, bounds.maximum) )
            range = FBRangeMake(0, 1);
        
        // See if this segment of the convex hull intersects with the maximum fat line bounds
        if ( LineIntersectsHorizontalLine(startPoint, endPoint, bounds.maximum, &intersectionPoint) ) {
            if ( intersectionPoint.x < range.minimum )
                range.minimum = intersectionPoint.x;
            if ( intersectionPoint.x > range.maximum )
                range.maximum = intersectionPoint.x;
        }
        // See the corresponding comment for the minimum intersection
        if ( [convexHull count] == 2 && FBAreValuesClose(startPoint.y, endPoint.y) && FBAreValuesClose(startPoint.y, bounds.maximum) && !FBAreValuesClose(bounds.minimum, bounds.maximum) )
            range = FBRangeMake(0, 1);
        
        // We want to be able to refine t even if the convex hull lies completely inside the bounds. This
        //  also allows us to be able to use range of [1..0] as a sentinel value meaning the convex hull
        //  lies entirely outside of bounds, and the curves don't intersect.
        if ( startPoint.y < bounds.maximum && startPoint.y > bounds.minimum ) {
            if ( startPoint.x < range.minimum )
                range.minimum = startPoint.x;
            if ( startPoint.x > range.maximum )
                range.maximum = startPoint.x;
        }
    }
    return range;
}

- (FBBezierCurve *) subcurveWithRange:(FBRange)range
{
    // Return a bezier curve representing the parameter range specified. We do this by splitting
    //  twice: once on the minimum, the splitting the result of that on the maximum.
    NSArray *curves1 = [self splitCurveAtParameter:range.minimum];
    FBBezierCurve *upperCurve = [curves1 objectAtIndex:1];
    if ( range.minimum == 1.0 )
        return upperCurve; // avoid the divide by zero below
    // We need to adjust the maximum parameter to fit on the new curve before we split again
    CGFloat adjustedMaximum = (range.maximum - range.minimum) / (1.0 - range.minimum);
    NSArray *curves2 = [upperCurve splitCurveAtParameter:adjustedMaximum];
    return [curves2 objectAtIndex:0];
}

- (NSArray *) splitSubcurvesWithRange:(FBRange)range
{
    // Return a bezier curve representing the parameter range specified. We do this by splitting
    //  twice: once on the minimum, the splitting the result of that on the maximum.
    NSMutableArray *subcurves = [NSMutableArray arrayWithCapacity:3];
    NSArray *curves1 = [self splitCurveAtParameter:range.minimum];
    if ( range.minimum == 0.0 )
        [subcurves addObject:[NSNull null]];
    else
        [subcurves addObject:[curves1 objectAtIndex:0]];
    FBBezierCurve *upperCurve = [curves1 objectAtIndex:1];
    if ( range.minimum == 1.0 ) {
        [subcurves addObject:upperCurve];
        [subcurves addObject:[NSNull null]];
        return subcurves; // avoid the divide by zero below
    }
    // We need to adjust the maximum parameter to fit on the new curve before we split again
    CGFloat adjustedMaximum = (range.maximum - range.minimum) / (1.0 - range.minimum);
    NSArray *curves2 = [upperCurve splitCurveAtParameter:adjustedMaximum];
    [subcurves addObjectsFromArray:curves2];
    return subcurves;
}

- (FBBezierCurve *) reversedCurve
{
	FBBezierCurve *reversedCurve = [[[self class] alloc] initWithEndPoint1:self.endPoint2 controlPoint1:self.controlPoint2 controlPoint2:self.controlPoint1 endPoint2:self.endPoint1];
	[reversedCurve setIsStraightLine:self.isStraightLine];
	return [reversedCurve autorelease];
}



- (CGPoint) pointAtParameter:(CGFloat)parameter leftBezierCurve:(FBBezierCurve **)leftBezierCurve rightBezierCurve:(FBBezierCurve **)rightBezierCurve
{    
    // This method is a simple wrapper around the BezierWithPoints() helper function. It computes the 2D point at the given parameter,
    //  and (optionally) the resulting curves that splitting at the parameter would create.
    
    CGPoint points[4] = { _endPoint1, _controlPoint1, _controlPoint2, _endPoint2 };
    CGPoint leftCurve[4] = {};
    CGPoint rightCurve[4] = {};

    CGPoint point = BezierWithPoints(3, points, parameter, leftCurve, rightCurve);
    
    if ( leftBezierCurve != nil ) {
        *leftBezierCurve = [FBBezierCurve bezierCurveWithEndPoint1:leftCurve[0] controlPoint1:leftCurve[1] controlPoint2:leftCurve[2] endPoint2:leftCurve[3]];
		[*leftBezierCurve setIsStraightLine:self.isStraightLine];	// GPC: propagate straight line flag to subcurves
	}
    if ( rightBezierCurve != nil ) {
        *rightBezierCurve = [FBBezierCurve bezierCurveWithEndPoint1:rightCurve[0] controlPoint1:rightCurve[1] controlPoint2:rightCurve[2] endPoint2:rightCurve[3]];
		[*rightBezierCurve setIsStraightLine:self.isStraightLine];	// GPC: propagate straight line flag to subcurves
	}
    return point;
}

- (CGFloat) refineParameter:(CGFloat)parameter forPoint:(CGPoint)point
{
    // Use Newton's Method to refine our parameter. In general, that formula is:
    //
    //  parameter = parameter - f(parameter) / f'(parameter)
    //
    // In our case:
    //
    //  f(parameter) = (Q(parameter) - point) * Q'(parameter) = 0
    //
    // Where Q'(parameter) is tangent to the curve at Q(parameter) and orthogonal to [Q(parameter) - P]
    //
    // Taking the derivative gives us:
    //
    //  f'(parameter) = (Q(parameter) - point) * Q''(parameter) + Q'(parameter) * Q'(parameter)
    //
    
    CGPoint bezierPoints[4] = {_endPoint1, _controlPoint1, _controlPoint2, _endPoint2};
    
    // Compute Q(parameter)
    CGPoint qAtParameter = BezierWithPoints(3, bezierPoints, parameter, nil, nil);
    
    // Compute Q'(parameter)
    CGPoint qPrimePoints[3] = {};
    for (NSUInteger i = 0; i < 3; i++) {
        qPrimePoints[i].x = (bezierPoints[i + 1].x - bezierPoints[i].x) * 3.0;
        qPrimePoints[i].y = (bezierPoints[i + 1].y - bezierPoints[i].y) * 3.0;
    }
    CGPoint qPrimeAtParameter = BezierWithPoints(2, qPrimePoints, parameter, nil, nil);
    
    // Compute Q''(parameter)
    CGPoint qPrimePrimePoints[2] = {};
    for (NSUInteger i = 0; i < 2; i++) {
        qPrimePrimePoints[i].x = (qPrimePoints[i + 1].x - qPrimePoints[i].x) * 2.0;
        qPrimePrimePoints[i].y = (qPrimePoints[i + 1].y - qPrimePoints[i].y) * 2.0;        
    }
    CGPoint qPrimePrimeAtParameter = BezierWithPoints(1, qPrimePrimePoints, parameter, nil, nil);
    
    // Compute f(parameter) and f'(parameter)
    CGPoint qMinusPoint = FBSubtractPoint(qAtParameter, point);
    CGFloat fAtParameter = FBDotMultiplyPoint(qMinusPoint, qPrimeAtParameter);
    CGFloat fPrimeAtParameter = FBDotMultiplyPoint(qMinusPoint, qPrimePrimeAtParameter) + FBDotMultiplyPoint(qPrimeAtParameter, qPrimeAtParameter);
    
    // Newton's method!
    return parameter - (fAtParameter / fPrimeAtParameter);
}

- (NSArray *) splitCurveAtParameter:(CGFloat)parameter
{
    // Convience method that returns the result of splitting at the given parameter
    FBBezierCurve *leftCurve = nil;
    FBBezierCurve *rightCurve = nil;
    [self pointAtParameter:parameter leftBezierCurve:&leftCurve rightBezierCurve:&rightCurve];
    return [NSArray arrayWithObjects:leftCurve, rightCurve, nil];
}

- (CGFloat) length
{
    return [self lengthAtParameter:1.0];
}

- (CGFloat) lengthAtParameter:(CGFloat)parameter
{
    return FBGaussQuadratureComputeCurveLengthForCubic(parameter, 12, _endPoint1, _controlPoint1, _controlPoint2, _endPoint2);
}

- (NSArray *) convexHull
{
    // Compute the convex hull for this bezier curve. The convex hull is made up of the end and control points.
    //  The hard part is determine the order they go in, and if any are inside or colinear with the convex hull.
    
    // We're using the Graham Scan algorithm to determine the convex hull. It finds the points that form the outside
    //  bounds of the curve.
    //
    // See also: http://en.wikipedia.org/wiki/Graham_scan
    //  and     http://softsurfer.com/Archive/algorithm_0109/algorithm_0109.htm
    
    // Start with all the end and control points in any order.
    NSMutableArray *points = [NSMutableArray arrayWithObjects:[NSValue valueWithCGPoint:_endPoint1], [NSValue valueWithCGPoint:_controlPoint1], [NSValue valueWithCGPoint:_controlPoint2], [NSValue valueWithCGPoint:_endPoint2], nil];

    // First, find the point that is on the bottom right, and move it to the first position in our array.
    NSUInteger lowestIndex = 0;
    CGPoint lowestValue = [[points objectAtIndex:0] CGPointValue];
    for (NSUInteger i = 0; i < [points count]; i++) {
        CGPoint point = [[points objectAtIndex:i] CGPointValue];
        if ( point.y < lowestValue.y || (FBAreValuesClose(point.y, lowestValue.y) && point.x > lowestValue.x) ) {
            lowestIndex = i;
            lowestValue = point;
        }
    }
    [points exchangeObjectAtIndex:0 withObjectAtIndex:lowestIndex];

    // Sort the points by the angle they form with the horizontal line on the lowest point, ascending.
    //  Remember any redundant (i.e. colinear) points so we can remove them later.
    NSMutableArray *pointsToDelete = [NSMutableArray arrayWithCapacity:4];
    [points sortUsingComparator:^NSComparisonResult(id obj1, id obj2) {
        CGPoint point1 = [obj1 CGPointValue];
        CGPoint point2 = [obj2 CGPointValue];
        
        // Special case: Our pivot value (lowestValue, at index 0) should stay at the lowest
        if ( CGPointEqualToPoint(lowestValue, point1) )
            return NSOrderedAscending;
        if ( CGPointEqualToPoint(lowestValue, point2) )
            return NSOrderedDescending;
        
        // We don't care about the actual angle value, just their values relative to each other.
        //  Compute the signed area of the triangle the points form, as a quick estimate of
        //  where the points lie relative to each other.
        CGFloat area = CounterClockwiseTurn(lowestValue, point1, point2);
        if ( FBAreValuesClose(area, 0.0) ) {
            // Ugh, the points are colinear. That means at least one of the points is going
            //  to be redundant, specifically the one closest to the pivot point. Remember
            //  the redundant point so it can be deleted later.
            CGFloat distance1 = FBDistanceBetweenPoints(point1, lowestValue);
            CGFloat distance2 = FBDistanceBetweenPoints(point2, lowestValue);
            // The three points are colinear, so base it on distance instead
            if ( distance1 < distance2 ) {
                [pointsToDelete addObject:obj1];
                return NSOrderedAscending;
            } else if ( distance1 > distance2 ) {
                [pointsToDelete addObject:obj2];
                return NSOrderedDescending;
            }
            // At this point, the decision is somewhat arbitrary since the distances are the
            //  same. However, we should prefer deleting an interior point over an exterior
            if ( point1.x == 0.0 || point1.x == 1.0 )
                [pointsToDelete addObject:obj2];
            else
                [pointsToDelete addObject:obj1];            
            return NSOrderedSame;
        } else if ( area < 0.0 )
            // point2 is to the right of the line formed by lowestValue, point1
            return NSOrderedDescending;
        //else if ( area > 0.0 )
        // point2 is left of the line formed by lowestValue, point1
        return NSOrderedAscending;                    
    }];
    // Remove any colinear points
    for (NSValue *value in pointsToDelete)
        [points removeObject:value];
    
    // We want to create an array of points where we only ever turn left.
    // Push the first two points onto the top of the results stack. Consider the point at i
    //  in the points array. If it causes the results array to turn left (counter clock wise),
    //  then add it to the results, then move on to consider the next point in points array.
    //  If it causes the results array to turn right, then remove the top of the results stack
    //  and try the point at i again.
    NSMutableArray *results = [NSMutableArray arrayWithCapacity:4];
    [results addObject:[points objectAtIndex:0]];
    [results addObject:[points objectAtIndex:1]];
    NSUInteger i = 2;
    while ( i < [points count] ) {
        CGPoint lastPoint = [[results lastObject] CGPointValue];
        CGPoint nextToLastPoint = [[results objectAtIndex:[results count] - 2] CGPointValue];
        CGPoint pointUnderConsideration = [[points objectAtIndex:i] CGPointValue];
        CGFloat area = CounterClockwiseTurn(nextToLastPoint, lastPoint, pointUnderConsideration);
        if ( area > 0.0 ) {
            // Turning left is good, so keep going
            [results addObject:[points objectAtIndex:i]];
            i++;
        } else {
            // Turning right is bad, so remove the top point
            [results removeLastObject];
            // We have to have at least two points, so if we drop below that, just take the
            //  one under consideration, and move on
            if ( [results count] < 2 ) {
                [results addObject:[points objectAtIndex:i]];
                i++;
            }
        }
    }
    
    return results;    
}

- (BOOL) isPoint
{
    // If the two end points are close together, then we're a point. Ignore the control
    //  points.
    static const CGFloat FBClosenessThreshold = 1e-5;
    
    return FBArePointsCloseWithOptions(_endPoint1, _endPoint2, FBClosenessThreshold) 
        && FBArePointsCloseWithOptions(_endPoint1, _controlPoint1, FBClosenessThreshold) 
        && FBArePointsCloseWithOptions(_endPoint1, _controlPoint2, FBClosenessThreshold);
}

- (CGRect) bounds
{    
    // Start with the end points
    CGPoint topLeft = [self pointAtParameter:0 leftBezierCurve:nil rightBezierCurve:nil];
    CGPoint bottomRight = topLeft;
    CGPoint lastPoint = [self pointAtParameter:1 leftBezierCurve:nil rightBezierCurve:nil];
    FBExpandBoundsByPoint(&topLeft, &bottomRight, lastPoint);
    
    // Find the roots, which should be the extremities
    NSArray *xRoots = FBComputeCubicFirstDerivativeRoots(_endPoint1.x, _controlPoint1.x, _controlPoint2.x, _endPoint2.x);
    for (NSNumber *root in xRoots) {
        CGFloat t = [root floatValue];
        if ( t < 0 || t > 1 )
            continue;
        
        CGPoint location = [self pointAtParameter:t leftBezierCurve:nil rightBezierCurve:nil];
        FBExpandBoundsByPoint(&topLeft, &bottomRight, location);
    }
    
    NSArray *yRoots = FBComputeCubicFirstDerivativeRoots(_endPoint1.y, _controlPoint1.y, _controlPoint2.y, _endPoint2.y);
    for (NSNumber *root in yRoots) {
        CGFloat t = [root floatValue];
        if ( t < 0 || t > 1 )
            continue;
        
        CGPoint location = [self pointAtParameter:t leftBezierCurve:nil rightBezierCurve:nil];
        FBExpandBoundsByPoint(&topLeft, &bottomRight, location);
    }
    
    return CGRectMake(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
}

- (UIBezierPath *) bezierPath
{
    UIBezierPath *path = [UIBezierPath bezierPath];
    [path moveToPoint:_endPoint1];
    [path addCurveToPoint:_endPoint2 controlPoint1:_controlPoint1 controlPoint2:_controlPoint2];
    return path;
}

- (NSString *) description
{
    return [NSString stringWithFormat:@"<%@ (%.18f, %.18f)-[%.18f, %.18f] curve to [%.18f, %.18f]-(%.18f, %.18f)>", 
            NSStringFromClass([self class]), 
            _endPoint1.x, _endPoint1.y, _controlPoint1.x, _controlPoint1.y,
            _controlPoint2.x, _controlPoint2.y, _endPoint2.x, _endPoint2.y];
}

@end
